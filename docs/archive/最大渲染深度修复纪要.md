---
title: 最大渲染深度修复纪要
owner: @codex
status: archived
updated: 2025-02-16
expires: 2025-05-16
tier: feature
relates: []
---

## 背景

- 在集成 AI 功能的回归测试中，主编辑器触发 React 的 `Maximum update depth exceeded`。
- 调试堆栈表明循环发生在 `components/ui/editor.tsx` → `PlateContent`，即编辑器在渲染阶段不断触发回写，形成受控闭环。

## 根因

- `components/editor/plate-editor.tsx` 通过 `useEditorKit` 把文档内容以 `value` 受控方式传入 `usePlateEditor`。
- 编辑器每次 `onChange` 会 `dispatch` 更新文档内容，新的 `value` 又在下一次渲染传回 `Plate`，导致“渲染 → onChange → setState → 再渲染”循环。

## 解决方案

- 在文档模型中新增 `contentVersion` 字段，初次水合或外部合并内容时递增，作为编辑器重挂载的判定信号。
- 同步维护 `initialContent` 快照，仅在 `contentVersion` 变化时刷新，避免运行时内容影响初始挂载。
- `PlateEditor` 仅在 `contentVersion > 0` 时渲染，且以 `${doc.id}:${contentVersion}` 作为 `<Plate>` 的 key，确保首轮水合后重建一次实例。
- `EditorInstance` 通过 `useMemo` + `cloneValue` 生成只受 `doc.id` 与 `contentVersion` 影响的初始快照，交由 `useEditorKit` 创建非受控编辑器。
- 继续沿用携带 `docId` 的 `onChange`，只做持久化，不再回写受控 value；插件装配保持 `useMemo` 稳定。

## 代码位置

- `components/editor/plate-editor.tsx#L18`
- `components/editor/editor-kit.tsx#L11`

## 后续关注

- 若未来引入远程回放/协同，需要在外部状态变动时显式同步编辑器内部内容，但该场景不会重新启用受控模式。
