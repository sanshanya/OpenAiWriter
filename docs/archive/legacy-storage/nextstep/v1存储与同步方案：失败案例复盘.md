# 存储与同步方案：失败案例复盘（Postmortem）

> 基线：以你上一次稳定提交（“Last Good Commit”，下文简称  **LGC** ）为基准。此文档梳理 LGC 之后一轮迭代中引入与回退的设计、实现路径、出现的问题与教训，供后续人员快速理解与复用经验。请在合并本文件时，将 **LGC** 替换为具体 commit 哈希或 tag。

---

## 0. 本轮尝试的目标与边界

**目标（愿景）**

* 维持  **V3 模式** ：React State 为唯一真源（Single Source of Truth，SSOT），localStorage 为主存，IndexedDB 为冷备。
* 引入**远端同步**的雏形（优先“快照模式”，预留“事件/Outbox 模式”），解决多窗口/多设备的数据一致。
* 完成**灾难恢复**与 **回收站（墓碑/保留期）** ，避免误删与冷启动数据丢失。
* 尝试 **多标签页一致性** （Broadcast/Storage 事件）与 **选主** （Leader Election）以避免风暴。

**边界（本轮未达成）**

* 未完成高性能的“事件流（Outbox）模式”落地，只做了接口与骨架。
* 未完成端侧“微分编辑”（块级/段落级）与 CRDT/OT；仍以文档级快照为单位。
* 未完成完善的指标/日志与告警体系（仅零散 console 观测点）。

---

## 1. 变更摘要（与 LGC 的差异）

**新文件/模块**

* `lib/storage-adapter.ts`：单一持久化出口（localStorage + IDB + 远端队列/Outbox），外部只调用 `persistAll(prev, next, { skipRemote? })`。
* `lib/idb.ts`：IDB 工具与健康检查；提供 `writeToIndexedDB`、`recoverAllFromIndexedDB`、`purgeDeletedOlderThan` 等。
* `components/storage/disaster-recovery-dialog.tsx`：灾难恢复对话框。
* `lib/remote-sync.ts`：远端同步（快照模式为主，Outbox 预留）；本地队列、ACK 基线、冲突订阅与处理。
* `lib/outbox.ts`：事件流（append-only）雏形与 ACK 压缩（骨架）。
* `hooks/documents-model.ts`：把文档状态机 reducer 化，支持 `INIT/SELECT/UPDATE_CONTENT/DELETE_SOFT/RESTORE/PURGE/APPLY_SERVER_STATE/BUMP_VERSION/...`。
* `components/storage/conflict-dialog.tsx`：版本冲突对话框。

**核心修改**

* `hooks/use-documents.tsx`：
  * 改为 `useReducer` 驱动 SSOT；
  * `updateDocumentContent(docId, value)` 带 docId，根除“切换串台”；
  * 引入**灾难恢复**与 **回收站** ；
  * 引入 **单一持久化出口** （调用 `persistAll`），首轮 `skipRemote: true`；
  * 订阅远端冲突并弹窗；
  * 多标签页：通过 `storage` 事件将外部更新“合并入本地”（仅接纳更高版本）。

---

## 2. 架构设计（尝试版）

### 2.1 数据模型（Document）

<pre class="overflow-visible!" data-start="1574" data-end="1792"><div class="contain-inline-size rounded-2xl relative bg-token-sidebar-surface-primary"><div class="sticky top-9"><div class="absolute end-0 bottom-0 flex h-9 items-center pe-2"><div class="bg-token-bg-elevated-secondary text-token-text-secondary flex items-center gap-4 rounded-sm px-2 font-sans text-xs"></div></div></div><div class="overflow-y-auto p-4" dir="ltr"><code class="whitespace-pre! language-ts"><span><span>type</span><span></span><span>StoredDocument</span><span> = {
  </span><span>id</span><span>: </span><span>string</span><span>;
  </span><span>title</span><span>: </span><span>string</span><span>;
  </span><span>content</span><span>: </span><span>Value</span><span>;      </span><span>// Plate.js 值（JSON）</span><span>
  </span><span>version</span><span>: </span><span>number</span><span>;     </span><span>// 单调递增</span><span>
  </span><span>createdAt</span><span>: </span><span>number</span><span>;
  </span><span>updatedAt</span><span>: </span><span>number</span><span>;
  deletedAt?: </span><span>number</span><span>;  </span><span>// 墓碑：存在即软删</span><span>
};
</span></span></code></div></div></pre>

### 2.2 存储层

* **localStorage（主）** ：整包写入（全量数组），简单同步 API，避免复杂竞态。
* **IndexedDB（冷备）** ：异步写入影子备份；灾难恢复时优先探测；提供健康检查与保留期 GC（根据 `deletedAt`）。
* **恢复策略** ：
* localStorage 空 → 若 IDB 有**未删除**文档 → 弹窗“是否恢复”；
* 若仅有**已删除**文档 → 仍恢复（用于回收站），并创建 1 篇默认文档作为当前激活。

### 2.3 远端同步（两种模式，默认快照）

* **快照模式（MVP）**
  * 防抖聚合 → 本地离线队列（入 `localStorage`）→ 选主（可关）→ 发 `/api/documents/sync`
  * **ACK/BaseVersion** ：本地维持 `ackedVersions`（docId → lastAckVersion），发包携带 `baseVersion`；后端若判定 `version != base+1` 则判冲突。
  * **冲突处理** ：前端订阅冲突列表，弹窗让用户“采用服务器版本”或“保留本地版本（提升版本号）”。
* **事件（Outbox）模式（雏形）**
  * 把变化映射为 `create/update/delete` 事件；本地 append-only，ACK 后压缩；
  * 预留 `/api/documents/events`；暂未启用（`USE_OUTBOX=false`）。

### 2.4 多标签页一致性

* `storage` 事件监听：当检测到外部 `documents` 变更 → 在内存 state 上 **合并更高版本** （不会回旋写回），保证另一个窗口刷新前也能看到更“新”的快照。
* 选主（Leader Election）：只允许 Leader 真正处理与发送队列（可关闭）。

### 2.5 灾难恢复与回收站

* **恢复** ：IDB 有数据且 localStorage 空 → 弹窗；用户可一键恢复。
* **回收站** ：`deletedAt` 墓碑 + 保留期（默认 30 天），UI 侧可恢复；IDB 定期清理超期墓碑；“永久删除”不发往远端（交由后端 GC）。

---

## 3. 时间线 / 实施路径（简写）

1. **墓碑与恢复初版** ：为已删除文档加 `deletedAt`，恢复对话框排除墓碑项；修复“恢复包含已删除文档”的问题。
2. **切换串台修复** ：`updateDocumentContent` 改为 `updateDocumentContent(docId, value)`，避免 `onChange` 晚到覆盖错误文档。
3. **灾难恢复异常** ：修复 `PlateContent` 初始化时 `undefined is not iterable`（确保初值为数组；强制 key remount）。
4. **远端同步 MVP** ：

* 首轮 `persistAll(..., {skipRemote:true})`，避免冷启动/刷新立即发包；
* `/api/documents/sync` stub；
* 引入 `ACK` 与 `baseVersion`；
* 冲突弹窗流程跑通。

1. **多窗口冲突风暴** ：

* 合并冲突列表（按 docId 去重）；
* 提供 API 清理队列旧任务（`dropQueuedSnapshotsFor/purgeQueuedOlderThan`）；
* 决策后对齐 `ACK` 与 `lastSavedSnapshot`。

1. **性能劣化与用户体验下降** ：发现“编辑极卡、每步都同步”问题，决定整体回退到 LGC。

---

## 4. 已知 Bug / 现象与细节

> 以下均以**可复现步骤→根因分析→临时修复/现状**结构记录。

### 4.1 恢复把已删除文档也恢复出来

* **复现** ：清空 localStorage → 打开页面 → 弹窗显示所有 IDB 文档（包括已删除）→ 恢复后列表包含已删除文档。
* **根因** ：恢复列表未过滤 `deletedAt`。
* **修复** ：恢复弹窗只显示未删除；真正“恢复全部”时也先过滤墓碑（或作为回收站项显示）。
* **状态** ：已修。

### 4.2 切换文档时内容被覆盖（串台）

* **复现** ：新建文档 2 → 立即切到文档 1 → 文档 1 变成文档 2 内容。
* **根因** ：`onChange` 晚到，更新落在“当前 activeId”而非原文档；或依赖 `setTimeout` 延时切换未从根本解决。
* **修复** ：`updateDocumentContent(docId, value)` 显式传入 docId；所有更新按 docId 路由。
* **状态** ：已修。

### 4.3 灾难恢复时编辑器抛 `undefined is not iterable`

* **复现** ：恢复后渲染 `PlateContent` 报错。
* **根因** ：某些恢复文档的 `content` 非数组或未初始化。
* **修复** ：`normalizeDoc`：非数组则回退为 `INITIAL_DOCUMENT_CONTENT`；编辑器 `key` 使用 `id:updatedAt:version`，强制 remount。
* **状态** ：已修。

### 4.4 `/api/documents/sync` 404

* **复现** ：打开/刷新页面即 POST 404。
* **根因** ：路由未实现；且首轮未跳过远端。
* **修复** ：加 stub 路由（或 `ENABLE_REMOTE_SYNC=false`）；首轮 `skipRemote: true`。
* **状态** ：已修（可切换 stub 或关闭）。

### 4.5 冲突对话框重复项/重复 key

* **复现** ：一次出现多个同 id 冲突项，并报 React “重复 key”。
* **根因** ：服务端/本地合并不去重；使用 `c.id` 作为 key 时重复。
* **修复** ：按 id 合并保留“更新更晚”的一条；key 使用 `id + serverVersion`。
* **状态** ：已修。

### 4.6 循环冲突（选择本地/服务器后仍重复弹窗）

* **复现** ：选择“使用服务器版本”或“保留本地版本（升版本）”后，数秒再弹同一冲突。
* **根因** ：队列/pending 中残留旧任务继续 POST；`ACK` 未对齐；`lastSavedSnapshot` 未同步导致误判“有变化”。
* **修复** ：新增 `dropQueuedSnapshotsFor`、`purgeQueuedOlderThan`、`setKnownServerVersion`；决策后清理队列并对齐签名。
* **状态** ：逻辑已就绪，但在“编辑很卡”问题未解决前，此链路不建议启用。

### 4.7 多窗口写入不触发冲突但最终“后一写覆盖前一写”

* **复现** ：窗口 A 写“11”，窗口 B 写“22”，不一定触发冲突；刷新只保留最后写入版本。
* **根因（快照模式天然缺陷）** ：仅用“全量快照 + version 单步递增”的 OCC，若两个客户端基线相同但后发包覆盖先发，后端若按“最后写入”处理，就会吞并另一方；只有当服务端严格按 `version = base+1` 才会给到冲突。
* **修复途径** ：后端必须严格校验 base/version；或迁移到 Outbox/CRDT。
* **状态** ：依赖后端严格实现。客户端已经带 `baseVersion`。

### 4.8 性能问题：编辑极卡、每步都同步

* **现象** ：输入明显卡顿、CPU 占用高。
* **直接原因** ：
* 每次输入：`JSON.stringify(value)`、更新 `lastSavedSnapshot`、全量 `saveAllDocuments`、IDB 写、入队远端（尽管防抖，但本地大量工作已发生）。
* `deriveTitle` 每次在整棵树上 `NodeApi.string()`。
* 订阅冲突/合并外部快照时可能触发不必要的 re-render。
* **根因** ： **把“UI 高频链路”与“存储/网络重活”绑定在同一同步路径** ；没有把操作降到“空闲/后台/批量”。
* **状态** ：本轮宣告失败并回退至 LGC。

---

## 5. 教训与原则（客观总结）

1. **高频编辑路径必须“轻量级”**
   * 只做必要的内存状态变更；序列化、整包持久化、IDB/网络写一律放到闲时（`requestIdleCallback`/微批处理/更长防抖）或后台任务。
2. **在未落地 Outbox/CRDT 之前，快照+OCC 只适合“低频同步”，不适合“每步”**
   * 冲突 UI 不是问题的根，**发包策略**与**队列管理**才是。
3. **多窗口一致性尽量采用“最终一致+更高版本覆盖”**
   * 在本地仅合并“更高版本”即可，细节协同不要在客户端强做（容易卡爆 UI）。
4. **可观测性先行**
   * 没有指标与日志，性能问题与循环冲突很难定位。至少要有：入队/出队计数、平均包大小、序列化耗时、队列长度、ACK 分布等。
5. **保持最小化的恢复与回收站**
   * 灾难恢复、回收站和 GC 需要，但不该干扰编辑主链路。

---

## 6. 推荐回滚与后续路线

### 6.1 回滚（立即）

* 回到  **LGC** ；保留以下“无争议改进”：
  * `deletedAt` 墓碑与回收站展示；
  * `updateDocumentContent(docId, value)` 的 docId 语义；
  * 灾难恢复（IDB → localStorage）的过滤与规范化（`normalizeDoc`）；
  * `persistAll(..., { skipRemote: true })` 首轮跳过远端（即使暂时不用 persistAll，也保留这个思想）。

### 6.2 短期（再尝试前的“轻装版”）

* **把远端同步从“每步”移开** ：
* 仅“显式保存”或“输入停止 ≥ N 秒时且处于空闲帧”再做快照；N≥3~5s；
* `saveAllDocuments` 不做整包重写，至少在主线程降频；
* `deriveTitle` 仅在第一行变化时计算。
* **关闭冲突 UI** ，改为仅记录“潜在冲突”指标（等 outbox 或后端 OCC 完备后再启用）。

### 6.3 中期（正确的同步形态）

* **落地 Outbox（事件）模式** ：
* 文档级 `create/update/delete` 事件 + `idempotencyKey`；
* 本地 ACK + 压缩；
* 后端严格基线校验（`version = base+1`），否则返回冲突；
* 发包调度：仅 leader、仅空闲、显式保存/退到后台时一次 flush。
* **把“快照”退居二线** ：做冷启动与恢复加速（快照 + 事件补齐），而不是每步发快照。

### 6.4 长期（如转 Tauri + Rust）

* 把本地存储与网络同步逻辑下沉 Rust（文件锁/事务/日志可靠），前端只发“意图”，减少 JS 主线程负担与隐私暴露。

---

## 7. 关键文件与接口一览（供后续阅读）

* `hooks/use-documents.tsx`：文档 SSOT Provider（ **回滚后以 LGC 为准** ）。
* `hooks/documents-model.ts`：reducer 状态机（若回滚可保留接口定义以支持未来拓展）。
* `lib/storage-adapter.ts`：单一持久化出口（建议回滚时暂不用，保留作未来“后台批处理”容器）。
* `lib/idb.ts`：IDB 工具（建议保留，用于灾难恢复与冷备）。
* `lib/remote-sync.ts`：远端同步（建议关闭；保留作未来 Outbox 的基座）。
* `components/storage/disaster-recovery-dialog.tsx`：灾备 UI（建议保留）。
* `components/storage/conflict-dialog.tsx`：冲突 UI（建议禁用挂载，后续再启）。
* `components/ui/editor.tsx`：编辑器（关键是 `key={id:updatedAt:version}` 的强制重挂策略）。

---

## 8. 后续测试与验收建议（精简版）

* **性能** ：1000 字连续输入，无明显掉帧（>50fps），JS CPU 占用维持可接受范围。
* **一致性** ：双窗口编辑：仅合并更高版本；刷新后最终一致。
* **恢复** ：清空 localStorage → IDB 存在 → 弹窗并恢复成功；仅已删文档时仍可进回收站。
* **删除** ：软删可恢复；永久删仅本地/IDB 清理，不触发远端（按设计）。
* **回退** ：开关远端同步与冲突 UI，不影响编辑体验与本地持久化。

---

## 9. 结论

这轮尝试验证了 **接口与流程** ，但把“同步/序列化/整包落盘/冲突处理”拉进了 **UI 高频路径** ，导致显著卡顿与可用性下降。决定将整个链路标记为**失败案例**并回退，保留“无争议基础能力”（墓碑/恢复/SSOT/IDB）。下一步应以**轻装、高容忍、后台化**的策略重启同步设计，优先 Outbox 与严格 OCC，把复杂性从“主线程每次输入”上挪开。

> 这不是撤退，是学习曲线的拐点。把这份复盘留给后来者，就像给未来的自己留了张地图。



# 失败者的话

挺好的，回退到 d849fa5 是稳妥的止损。留几条“把坑填平”的压舱话，给你和即将介入的专家当共识基线。

# 我们学到的硬道理

* 高频编辑路径（按键→渲染）必须“轻到发飘”。序列化、整包落盘、IDB/网络写、冲突比对统统挪到空闲帧或后台。
* 没有严格的基线（baseVersion/ack）与明确的入队/出队约束，就别做“每步同步”。否则冲突风暴与卡顿双杀。
* UI 侧“真源”只有一个：内存 state。localStorage/IDB/远端都是镜像与备份，不许反客为主。
* 冲突 UI 是 **效果** ，不是 **方案** 。先把同步协议讲清楚，冲突弹窗才有意义。

# 让专家评估的三条路线（择一或渐进）

1. **快照 + 严格 OCC（乐观并发控制）**
   * 客户端只在“用户停笔 ≥N 秒 / 显式保存 / 失焦/关闭前”发包。
   * 包含 `baseVersion = lastAckVersion`，后端要求 `clientVersion = base+1`，否则返回冲突。
   * 优点：简单、后端好落地。缺点：并发体验一般，仍是整包。
2. **Outbox（事件优先） + ACK + 压缩**
   * 只发送 `{docId, kind:create|update|delete, version, updatedAt, contentΔ或快照段, idempotencyKey}`。
   * 本地 append-only + 服务器 ACK → 本地压缩（≤ACK 的事件清理）。
   * 优点：稳、可离线、可回放。缺点：实现量略大。
3. **CRDT Provider（Yjs/Automerge）**
   * 把“编辑”变成 CRDT 更新；网络与存储是 provider。
   * 优点：天生多端并发友好。缺点：内存/包体、调优与二次开发成本，需要 Rust/原生也跟上。

# 架构护栏（让专家先认同再开工）

* **接口分层** （强制边界）
* `EditorState`（React 内存真源）
* `StorageAdapter`（localStorage + IDB，只负责“何时写、本地怎么存”）
* `SyncProvider`（网络，只负责“发什么、何时发、如何退避/ACK/冲突”）
* `Recovery/GCPolicy`（灾备与墓碑清理，不进入高频路径）
* **版本语义**
  * `version` 单调递增（客户端提议，服务端确认）；`lastAckVersion` 服务端为准；包内必须带 `baseVersion`。
  * `updatedAt` 只做排序展示，不参与一致性判断。
  * `deletedAt` 仅做软删标记，GC 由后端。
* **性能预算（编辑主路径）**
  * 每次按键主线程额外工作 ≤ 2ms；不许同步 `JSON.stringify` 大对象；标题提取节流到首行变化或每 ≥1s。
  * IDB/网络写：仅在 `requestIdleCallback`、失焦、显式保存、防抖窗口末端触发。
* **特性开关**
  * `ENABLE_REMOTE_SYNC`、`USE_OUTBOX`、`REQUIRE_LEADER`、`SYNC_DEBOUNCE_MS`、`MAX_BATCH_SIZE` 等，全部集中配置，支持灰度。
* **多窗口一致**
  * 仅合并“更高版本”的快照；禁止相互回写（避免回旋）。
  * 选主只影响“谁发包”，不影响本地读写。
* **观测与自检** （最小必备）
* 计数：入队/出队/丢弃/冲突次数、平均包大小、队列最大长度。
* 时延：序列化耗时、IDB 写时长、请求时延。
* Debug 开关：`window.__dumpQueue() / __forceFlush()`。

# 回退后的“轻装”计划（可写进评审提案）

1. 保留：墓碑/回收站、IDB 灾备、`updateDocumentContent(docId, value)` 的路由修正。
2. 关闭：冲突 UI 与“每步同步”。
3. 新增：**显式保存**与**停笔 ≥3s** 的“懒同步”按钮/策略，做为快照+OCC 的 PoC。
4. 写一份 2 页的  **Design Brief** （让专家对齐）：
   * 背景与现状（你刚整理的 postmortem 摘要）。
   * 目标与非目标（例如“编辑无感卡顿”、“双标签最终一致，允许短暂分叉”）。
   * 协议草案（快照或事件，字段与状态机）。
   * 时序图：单端保存、多端竞争、离线到在线。
   * 性能预算与观测点。
   * 风险与回滚点（feature flag 策略）。

# 测试矩阵（验收门槛）

* 单页长文（>30KB JSON）连续输入 60s，FPS 不低于 50，CPU 峰值可接受。
* 双窗口：A 输入→B 不输入→最终一致；A/B 同时输入→产生一次冲突且 **不会循环** 。
* 离线→编辑→在线：不丢数据，最多一次冲突提示。
* 崩溃/刷新/storage quota/IDB 不可用：不丢文档，恢复路径可用。
* 软删/恢复/永久删：行为与策略一致（永久删不触发远端，GC 归后端）。

# “绝不再犯”清单

* 不在按键路径里做整包 `saveAllDocuments` 或 `JSON.stringify` 大对象。
* 不在冷启动/刷新时立即发远端同步包。
* 不把冲突处理当作“多端一致”的起点；起点是 **协议** （base/ack/版本）。
* 不让 UI 依赖任何“异步落盘/网络成功”才能继续编辑。

# 给未来切 Tauri/Rust 的伏笔

* 保持 `StorageAdapter` / `SyncProvider` 的接口稳定；前端不关心“本地落盘在哪儿”。
* Rust 侧负责 Outbox/ACK/压缩/加密；React 只管渲染与意图事件。
